name: CD Deploy to Naver Cloud (Password Variant)

on:
  push:
    branches: [ "main" ]
  pull_request:
    types: [closed]
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: deploy-prod
  cancel-in-progress: true

env:
  APP_DIR: /opt/selfstar
  HEALTH_URL: http://localhost/health

jobs:
  deploy-password:
    name: Deploy via password (SCP + SSH)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' &&
       github.event.action == 'closed' &&
       github.event.pull_request.merged == true &&
       github.event.pull_request.base.ref == 'main')

    env:
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
      # 필요 시 주석 해제 (Secrets에 줄바꿈 포함 저장)
      # BACKEND_ENV_PROD: ${{ secrets.BACKEND_ENV_PROD }}
      # FRONTEND_ENV_PROD: ${{ secrets.FRONTEND_ENV_PROD }}
      # AI_ENV_PROD: ${{ secrets.AI_ENV_PROD }}

    steps:
      - name: Checkout (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Preflight validate required secrets
        run: |
          set -euo pipefail
          missing=0
          for v in SERVER_HOST SERVER_USER SERVER_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret: $v"; missing=1; fi; done
          if [ "$missing" -eq 1 ]; then
            echo "Configure SERVER_HOST/USER/PASSWORD in repo Secrets." >&2
            exit 1
          fi
          echo "All required secrets present."

      # --- (옵션) 환경파일 렌더링 ---
      - name: Render backend env (optional)
        if: env.BACKEND_ENV_PROD != ''
        run: |
          mkdir -p backend
          printf "%s" "${BACKEND_ENV_PROD}" > backend/.env.production

      - name: Render frontend env (optional)
        if: env.FRONTEND_ENV_PROD != ''
        run: |
          mkdir -p frontend
          printf "%s" "${FRONTEND_ENV_PROD}" > frontend/.env.production

      - name: Render AI env (optional)
        if: env.AI_ENV_PROD != ''
        run: |
          mkdir -p ai
          printf "%s" "${AI_ENV_PROD}" > ai/.env.production

      # --- SSH 사전 연결 테스트 ---
      - name: Preflight - verify SSH connectivity
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          script_stop: true
          script: |
            set -e
            echo "[SERVER] SSH OK: $(hostname)"

      # --- 사전 시스템 점검: sudo/도커/systemd 확인 + APP_DIR 생성 ---
      - name: Preflight - check docker & systemd & APP_DIR
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          script_stop: true
          envs: APP_DIR
          script: |
            set -euo pipefail
            APP_DIR="${APP_DIR:-/opt/selfstar}"

            # sudo 자동 감지
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
              SUDO="sudo"
            else
              SUDO=""
            fi

            # docker 확인 (PATH/권한)
            if ! command -v docker >/dev/null 2>&1; then
              if [ -n "$SUDO" ] && $SUDO command -v docker >/dev/null 2>&1; then
                :
              else
                echo "[SERVER][ERROR] docker not found in PATH." >&2
                exit 1
              fi
            fi
            if ! docker info >/dev/null 2>&1; then
              if [ -n "$SUDO" ] && $SUDO docker info >/dev/null 2>&1; then
                echo "[SERVER] docker requires sudo; will use sudo."
              else
                echo "[SERVER][ERROR] cannot access docker daemon." >&2
                exit 1
              fi
            fi

            # systemd 확인
            if ! command -v systemctl >/dev/null 2>&1; then
              echo "[SERVER][ERROR] systemctl not found." >&2
              exit 1
            fi

            # APP_DIR 준비
            if [ ! -d "$APP_DIR" ]; then
              $SUDO mkdir -p "$APP_DIR"
              $SUDO chown "${USER:-$LOGNAME}":"${USER:-$LOGNAME}" "$APP_DIR" || true
              echo "[SERVER] created $APP_DIR"
            fi

      # --- 코드 업로드(임시 폴더로): 숨김(.git 등) 제외, env 보존을 위한 준비 ---
      - name: Sync code to server (SCP to temp)
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          target: "${{ env.APP_DIR }}_upload"
          overwrite: true
          strip_components: 0
          # 쉘 글롭 '*'는 숨김항목(.git 등) 제외. 필요한 env.production은 명시 포함
          source: "./*,backend/.env.production,frontend/.env.production,ai/.env.production"

      # --- 배포: 업로드본 → 실제 APP_DIR 병합( env/ 보존 ) + 재시작 + 헬스체크 ---
      - name: Deploy on server (merge + systemd restart + health)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          script_stop: true
          envs: APP_DIR,HEALTH_URL
          script: |
            set -euo pipefail
            echo "[SERVER] Deploy start: $(date -u)"
            APP_DIR="${APP_DIR:-/opt/selfstar}"
            UPLOAD_DIR="${APP_DIR}_upload"
            HEALTH_URL="${HEALTH_URL:-http://localhost/health}"

            # sudo 감지
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
              SUDO="sudo"
            else
              SUDO=""
            fi

            # docker 접근자 설정
            if docker info >/dev/null 2>&1; then
              DOCKER="docker"
            elif [ -n "$SUDO" ] && $SUDO docker info >/dev/null 2>&1; then
              DOCKER="sudo docker"
            else
              echo "[SERVER][ERROR] cannot access docker daemon." >&2
              exit 1
            fi

            # docker compose 명령
            if command -v docker-compose >/dev/null 2>&1; then
              if [ "$DOCKER" = "docker" ]; then
                DC="docker-compose"
              else
                DC="sudo docker-compose"
              fi
            else
              DC="$DOCKER compose"
            fi

            # 업로드본/대상 디렉토리 확인
            if [ ! -d "$UPLOAD_DIR" ]; then
              echo "[SERVER][ERROR] Upload dir not found: $UPLOAD_DIR" >&2
              exit 1
            fi
            if [ ! -d "$APP_DIR" ]; then
              $SUDO mkdir -p "$APP_DIR"
              $SUDO chown "${USER:-$LOGNAME}":"${USER:-$LOGNAME}" "$APP_DIR" || true
            fi

            echo "[SERVER] Merging code from ${UPLOAD_DIR} into ${APP_DIR} (preserve env/)"
            if command -v rsync >/dev/null 2>&1; then
              # env/ 제외 병합 (서버에만 있는 파일은 유지; 필요시 --delete 추가)
              $SUDO rsync -a "${UPLOAD_DIR}/" "${APP_DIR}/" --exclude "env/"
            else
              # rsync 없으면 수동 병합
              shopt -s dotglob
              for p in "${UPLOAD_DIR}"/*; do
                b="$(basename "$p")"
                if [ "$b" = "env" ]; then
                  continue
                fi
                $SUDO rm -rf "${APP_DIR}/${b}"
                $SUDO cp -a "$p" "${APP_DIR}/"
              done
              shopt -u dotglob
            fi

            # 서버에 env/ 없으면 업로드본 채택(최초 설치 대비)
            if [ ! -d "${APP_DIR}/env" ] && [ -d "${UPLOAD_DIR}/env" ]; then
              echo "[SERVER] No server env/ found → adopting uploaded env/"
              $SUDO cp -a "${UPLOAD_DIR}/env" "${APP_DIR}/"
            else
              echo "[SERVER] Keeping existing server env/ as-is"
            fi

            # 임시 업로드 정리
            $SUDO rm -rf "${UPLOAD_DIR}"

            # 컴포즈 유효성 확인(있으면)
            cd "$APP_DIR"
            if [ -f docker-compose.yml ] || [ -f docker-compose.yaml ]; then
              echo "[SERVER] Compose config check"
              $DC config >/dev/null
            else
              echo "[SERVER][WARN] No docker-compose.yml found (systemd 내부 처리 가정)"
            fi

            # systemd 재시작
            echo "[SERVER] systemd reload & restart selfstar.service"
            if $SUDO systemctl list-unit-files | grep -q '^selfstar.service'; then
              $SUDO systemctl daemon-reload
              if ! $SUDO systemctl restart selfstar.service; then
                echo "[SERVER][ERROR] Failed to restart selfstar.service" >&2
                $SUDO systemctl status selfstar.service -n 100 --no-pager >&2 || true
                $SUDO journalctl -u selfstar.service -n 200 --no-pager >&2 || true
                $DOCKER ps -a >&2 || true
                exit 1
              fi
              if ! $SUDO systemctl is-active --quiet selfstar.service; then
                echo "[SERVER][ERROR] selfstar.service is not active after restart" >&2
                $SUDO systemctl status selfstar.service -n 100 --no-pager >&2 || true
                $SUDO journalctl -u selfstar.service -n 200 --no-pager >&2 || true
                $DOCKER ps -a >&2 || true
                exit 1
              fi
            else
              echo "[SERVER][ERROR] selfstar.service not found" >&2
              exit 1
            fi

            # 헬스체크
            echo "[SERVER] Health check on ${HEALTH_URL}"
            ok=0
            for i in $(seq 1 10); do
              code=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || true)
              if [ "$code" = "200" ] || [ "$code" = "204" ]; then
                echo "[SERVER] Health OK ($code)"
                ok=1
                break
              fi
              echo "[SERVER] Health not ready (got $code). retry $i/10..."
              sleep 3
            done
            if [ "$ok" -ne 1 ]; then
              echo "[SERVER][ERROR] Service unhealthy after deploy" >&2
              $SUDO systemctl status selfstar.service -n 100 --no-pager >&2 || true
              $SUDO journalctl -u selfstar.service -n 200 --no-pager >&2 || true
              $DOCKER ps -a >&2 || true
              exit 1
            fi

            # 정리
            echo "[SERVER] Prune dangling images"
            $DOCKER image prune -f || true
            echo "[SERVER] Deploy complete: $(date -u)"

      - name: Summary
        if: always()
        run: echo "배포 완료(또는 실패 시 위 단계 로그 확인). env/는 서버에 있으면 보존됩니다."
