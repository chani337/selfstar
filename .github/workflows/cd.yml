name: CD Deploy to Naver Cloud (Password Variant)

on:
  # 머지로 인해 main에 push가 발생했을 때만 동작
  push:
    branches: [ "main" ]
  # 필요 시 수동 실행 허용
  workflow_dispatch:

concurrency:
  group: deploy-prod
  cancel-in-progress: true

env:
  APP_DIR: /opt/selfstar
  # SSH 포트가 22가 아니면 repo Variables에 SSH_PORT를 추가하고 아래 주석 해제
  # SSH_PORT: ${{ vars.SSH_PORT }}

jobs:
  deploy-password:
    name: Deploy via password (SCP + SSH)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # PR 이벤트에서는 배포를 절대 실행하지 않음
    if: github.event_name != 'pull_request'

    env:
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      SERVER_USER:  ${{ secrets.SERVER_USER }}
      SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
      # 필요 시 주석 해제 (Secrets에 줄바꿈 포함 저장)
      # BACKEND_ENV_PROD:  ${{ secrets.BACKEND_ENV_PROD }}
      # FRONTEND_ENV_PROD: ${{ secrets.FRONTEND_ENV_PROD }}
      # AI_ENV_PROD:       ${{ secrets.AI_ENV_PROD }}

    steps:
      - name: Checkout (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Preflight - validate required secrets
        run: |
          set -euo pipefail
          missing=0
          for v in SERVER_HOST SERVER_USER SERVER_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret: $v"; missing=1; fi; done
          if [ "$missing" -eq 1 ]; then
            echo "Configure SERVER_HOST/USER/PASSWORD in repo Secrets." >&2
            exit 1
          fi
          echo "All required secrets present."

      # --- (옵션) 환경파일 렌더링 ---
      - name: Render backend env (optional)
        if: env.BACKEND_ENV_PROD != ''
        run: |
          mkdir -p backend
          printf "%s" "${BACKEND_ENV_PROD}" > backend/.env.production

      - name: Render frontend env (optional)
        if: env.FRONTEND_ENV_PROD != ''
        run: |
          mkdir -p frontend
          printf "%s" "${FRONTEND_ENV_PROD}" > frontend/.env.production

      - name: Render AI env (optional)
        if: env.AI_ENV_PROD != ''
        run: |
          mkdir -p ai
          printf "%s" "${AI_ENV_PROD}" > ai/.env.production

      # --- SSH 사전 연결 테스트 ---
      - name: Preflight - verify SSH connectivity
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          # port: ${{ env.SSH_PORT }}
          script_stop: true
          debug: true
          script: |
            set -euxo pipefail
            echo "[CHECK] SSH OK: $(hostname)"
            whoami
            uname -a

      # --- 사전 시스템 점검: sudo/도커/systemd 확인 + APP_DIR 생성 ---
      - name: Preflight - check docker & systemd & APP_DIR
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          # port: ${{ env.SSH_PORT }}
          script_stop: true
          debug: true
          envs: APP_DIR
          script: |
            set -euxo pipefail
            echo "[CHECK] start preflight"
            APP_DIR="${APP_DIR:-/opt/selfstar}"

            # sudo 감지
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then SUDO="sudo"; else SUDO=""; fi
            echo "[CHECK] sudo=${SUDO:-none}"

            # docker 접근성
            command -v docker
            if ! docker info >/dev/null 2>&1; then
              if [ -n "$SUDO" ] && $SUDO docker info >/dev/null 2>&1; then
                echo "[CHECK] docker needs sudo"
              else
                echo "[ERR] docker daemon no access"; exit 1
              fi
            fi

            # systemd 확인
            command -v systemctl || { echo "[ERR] systemctl missing"; exit 1; }

            # APP_DIR 준비
            if [ ! -d "$APP_DIR" ]; then
              ${SUDO:-} mkdir -p "$APP_DIR"
              ${SUDO:-} chown "${USER:-$LOGNAME}":"${USER:-$LOGNAME}" "$APP_DIR" || true
              echo "[CHECK] created $APP_DIR"
            fi
            ls -ald "$APP_DIR"
            echo "[CHECK] preflight OK"

      # --- 코드 업로드(임시 폴더로): 숨김(.git 등) 제외, env 보존을 위한 준비 ---
      - name: Sync code to server (SCP to temp)
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          # port: ${{ env.SSH_PORT }}
          target: "${{ env.APP_DIR }}_upload"
          overwrite: true
          strip_components: 0
          source: "./*,backend/.env.production,frontend/.env.production,ai/.env.production"
          debug: true

      # --- 배포: 업로드본 → 실제 APP_DIR 병합(env/ 보존) + compose 검증 + 재기동(직접 compose) ---
      - name: Deploy on server (merge + compose up)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          # port: ${{ env.SSH_PORT }}
          script_stop: true
          debug: true
          envs: APP_DIR
          script: |
            set -euxo pipefail
            echo "[DEPLOY] start $(date -u)"
            APP_DIR="${APP_DIR:-/opt/selfstar}"
            UPLOAD_DIR="${APP_DIR}_upload"

            # sudo / docker / compose(v2 고정)
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then SUDO="sudo"; else SUDO=""; fi
            if docker info >/dev/null 2>&1; then DOCKER="docker"; elif [ -n "$SUDO" ] && $SUDO docker info >/dev/null 2>&1; then DOCKER="sudo docker"; else echo "[ERR] docker daemon no access"; exit 1; fi
            DC="$DOCKER compose"   # docker compose만 사용

            # 병합 (env/ 보존)
            [ -d "$UPLOAD_DIR" ] || { echo "[ERR] upload dir missing"; exit 1; }
            [ -d "$APP_DIR" ] || { ${SUDO:-} mkdir -p "$APP_DIR"; ${SUDO:-} chown "${USER:-$LOGNAME}":"${USER:-$LOGNAME}" "$APP_DIR" || true; }

            echo "[DEPLOY] merge code (preserve env/)"
            if command -v rsync >/dev/null 2>&1; then
              ${SUDO:-} rsync -a "${UPLOAD_DIR}/" "${APP_DIR}/" --exclude "env/"
            else
              shopt -s dotglob
              for p in "${UPLOAD_DIR}"/*; do
                b="$(basename "$p")"
                [ "$b" = "env" ] && continue
                ${SUDO:-} rm -rf "${APP_DIR}/${b}"
                ${SUDO:-} cp -a "$p" "${APP_DIR}/"
              done
              shopt -u dotglob
            fi
            if [ ! -d "${APP_DIR}/env" ] && [ -d "${UPLOAD_DIR}/env" ]; then
              echo "[DEPLOY] adopt uploaded env/"
              ${SUDO:-} cp -a "${UPLOAD_DIR}/env" "${APP_DIR}/"
            fi
            ${SUDO:-} rm -rf "${UPLOAD_DIR}"

            # compose 파일 자동 탐지 & 검증
            cd "$APP_DIR"
            COMPOSE_FILE=""
            for f in docker-compose.prod.yml docker-compose.prod.yaml docker-compose.yml docker-compose.yaml; do
              if [ -f "$f" ]; then COMPOSE_FILE="$f"; break; fi
            done
            if [ -z "$COMPOSE_FILE" ]; then
              echo "[ERR] no compose file found (expected docker-compose.prod.yml)"; exit 1
            fi
            echo "[DEPLOY] compose config check with -f $COMPOSE_FILE"
            $DC -f "$COMPOSE_FILE" config >/dev/null

            # 직접 compose 재배포 (systemd 우회하여 에러 표면화)
            echo "[DEPLOY] compose up -d --build"
            $DC -f "$COMPOSE_FILE" pull --quiet || true
            if ! $DC -f "$COMPOSE_FILE" up -d --build; then
              echo "[ERR] compose up failed"
              $DC -f "$COMPOSE_FILE" ps || true
              $DC -f "$COMPOSE_FILE" logs --no-log-prefix --tail=200 || true
              exit 1
            fi
            $DC -f "$COMPOSE_FILE" ps
            # 최근 백엔드 로그 출력 (트러블슈팅용)
            $DC -f "$COMPOSE_FILE" logs --no-log-prefix --since=2m backend || true

            echo "[DEPLOY] prune images"
            $DOCKER image prune -f || true
            echo "[DEPLOY] done $(date -u)"

      - name: Summary
        if: always()
        run: echo "배포 플로우 종료. 실패 시 위 단계 로그를 확인하세요. 서버에 존재하는 env/는 보존됩니다."
